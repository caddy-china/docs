<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="zh-hans">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title> - Caddy 中文文档 Docs</title>
    <meta name="generator" content="Hugo 0.52" />

    
    <meta name="description" content="自动配置 HTTPS 的 HTTP2 服务器">
    
    <link rel="canonical" href="https://docs.getcaddy.cn/directive-middleware/">
    
    <meta name="author" content="caddy">
    

    <meta property="og:url" content="https://docs.getcaddy.cn/directive-middleware/">
    <meta property="og:title" content="Caddy 中文文档 Docs">
    <meta property="og:image" content="https://docs.getcaddy.cn/images/logo.png">
    <meta name="apple-mobile-web-app-title" content="Caddy 中文文档 Docs">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="https://docs.getcaddy.cn/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="https://docs.getcaddy.cn/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('https://docs.getcaddy.cn/fonts/icon.eot');
        src: url('https://docs.getcaddy.cn/fonts/icon.eot')
               format('embedded-opentype'),
             url('https://docs.getcaddy.cn/fonts/icon.woff')
               format('woff'),
             url('https://docs.getcaddy.cn/fonts/icon.ttf')
               format('truetype'),
             url('https://docs.getcaddy.cn/fonts/icon.svg')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="https://docs.getcaddy.cn/stylesheets/application.css">
    <link rel="stylesheet" href="https://docs.getcaddy.cn/stylesheets/temporary.css">
    <link rel="stylesheet" href="https://docs.getcaddy.cn/stylesheets/palettes.css">
    <link rel="stylesheet" href="https://docs.getcaddy.cn/stylesheets/highlight/atom-one-light.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="https://docs.getcaddy.cn/javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-light-blue palette-accent-light-blue">



	
	


<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        
      </div>
    </div>

    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/caddy" title="@caddy on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://github.com/mholt/caddy" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="https://docs.getcaddy.cn/images/logo.png">
        </div>
      
      <div class="name">
        <strong>Caddy 中文文档 Docs <span class="version">0.10.7</span></strong>
        
          <br>
          mholt/caddy
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
        <ul class="repo">
          <li class="repo-download">
            <a href="https://github.com/mholt/caddy/archive/master.zip" target="_blank" title="Download" data-action="download">
              <i class="icon icon-download"></i> Download
            </a>
          </li>
          <li class="repo-stars">
            <a href="https://github.com/mholt/caddy/stargazers" target="_blank" title="Stargazers" data-action="star">
              <i class="icon icon-star"></i> Stars
              <span class="count">&ndash;</span>
            </a>
          </li>
        </ul>
        <hr>
      

      <div class="toc">
        
        <ul>
          




<li>
  
    



<a  title="开始使用" href="https://docs.getcaddy.cn/get-started/">
	
	开始使用
</a>



  
</li>



<li>
  
    



<a  title="HTTP 服务器" href="https://docs.getcaddy.cn/http-server/">
	
	HTTP 服务器
</a>



  
</li>



<li>
  
    



<a  title="标准 HTTP 指令" href="https://docs.getcaddy.cn/http/">
	
	标准 HTTP 指令
</a>



  
</li>



<li>
  
    



<a  title="DNS 服务商" href="https://docs.getcaddy.cn/dns/">
	
	DNS 服务商
</a>



  
</li>



<li>
  
    



<a class="current" title="指令／中间件" href="https://docs.getcaddy.cn/directive-middleware/">
	
	指令／中间件
</a>


<ul id="scrollspy">
</ul>


  
</li>



<li>
  
    



<a  title="事件钩子" href="https://docs.getcaddy.cn/event-hooks/">
	
	事件钩子
</a>



  
</li>



<li>
  
    



<a  title="服务器类型" href="https://docs.getcaddy.cn/server-type/">
	
	服务器类型
</a>



  
</li>



<li>
  
    



<a  title="常用教程" href="https://docs.getcaddy.cn/examples/">
	
	常用教程
</a>



  
</li>


        </ul>
        

        
        <hr>
        <span class="section">The author</span>
        
        <ul>
          

          
          <li>
            <a href="https://github.com/caddy" target="_blank" title="@caddy on GitHub">
              @caddy on GitHub
            </a>
          </li>
          

          
          <li>
            <a href="mailto:admin@zuohuadong.cn" title="Email of admin@zuohuadong.cn">
              Contact via email
            </a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1> </h1>

			

<h2 id="http-authz">http.authz</h2>

<h2 id="http-awses">http.awses</h2>

<h2 id="http-awslambda">http.awslambda</h2>

<h2 id="http-cache">http.cache</h2>

<h2 id="http-cgi">http.cgi</h2>

<p>该插件实现了Caddy的通用网关接口（CGI）。它可以通过命令行脚本在您的网站上生成动态内容。如果要收集有关入站 HTTP 请求的信息，比如您的脚本会检查某些环境变量，例如 PATH_INFO 和 QUERY_STRING。然后，要将动态生成的网页返回给客户端，您的脚本只需将内容写入标准输出中即可。在POST请求的情况下，您的脚本从标准输入读取额外的入站内容。</p>

<h3 id="例子">例子</h3>

<p>CGI 脚本</p>

<pre><code>In the Caddyfile:

  cgi /report /usr/local/cgi-bin/report

In /usr/local/cgi-bin/report:

  #!/bin/bash

  printf &quot;Content-type: text/plain\n\n&quot;

  printf &quot;PATH_INFO    [%s]\n&quot; $PATH_INFO
  printf &quot;QUERY_STRING [%s]\n&quot; $QUERY_STRING

  exit 0
</code></pre>

<p>当 <a href="https://example.com/report或https://example.com/report/weekly">https://example.com/report或https://example.com/report/weekly</a> 等请求到达时，cgi中间件将检测到匹配项，并调用名为/usr/local/cgi-bin/report 的脚本。</p>

<p>环境变量 PATH_INFO 和 QUERY_STRING 被填充并自动传递给脚本。文档中描述了包含许多其他标准CGI变量。如果您需要传递任何特殊的环境变量，或者允许任何属于 Caddy 进程的环境变量传递给您的脚本，则需要使用文档中描述的高级指令语法。</p>

<p><a href="https://jung-kurt.github.io/cgi/">完整文档</a></p>

<h2 id="http-cors">http.cors</h2>

<p>支持跨源资源共享</p>

<h3 id="例子-1">例子</h3>

<p><strong>简单的使用</strong></p>

<pre><code>cors
</code></pre>

<p>允许所有来源访问所有资源</p>

<p><strong>只允许某些域名</strong></p>

<pre><code>cors / http://mytrusteddomain.tld http://myotherdomain.com
</code></pre>

<p>只允许来自几个特定域名的跨域请求</p>

<p><strong>完整配置</strong></p>

<pre><code>cors / {
    origin            http://allowedSite.com
    origin            http://anotherSite.org https://anotherSite.org
    methods           POST,PUT
    allow_credentials false
    max_age           3600
    allowed_headers   X-Custom-Header,X-Foobar
    exposed_headers   X-Something-Special,SomethingElse
}
</code></pre>

<p>显示所有可用选项的示例</p>

<h2 id="http-datadog">http.datadog</h2>

<h2 id="http-expires">http.expires</h2>

<h2 id="http-filemanager">http.filemanager</h2>

<p>filemanager 是基于浏览中间件的扩展。它提供指定目录中的文件管理界面，可用于上传，删除，预览和重命名该目录中的文件。</p>

<p>如果您遇到处理大文件的问题，您可能需要检查该 <a href="https://docs.getcaddy.cn/http/#timeout">timeouts 插件</a>，该插件可用于更改默认 HTTP 超时。</p>

<h3 id="例子-2">例子</h3>

<p><strong>基本用法</strong></p>

<pre><code>filemanager
</code></pre>

<p>显示在域的根处执行Caddy的目录。</p>

<p><strong>浏览具体路径</strong></p>

<pre><code>filemanager / ./foo
</code></pre>

<p>显示<code>foo</code>域的根目录内容。</p>

<p><strong>浏览特定目录</strong></p>

<pre><code>filemanager /filemanager
</code></pre>

<p>显示 Caddy 执行的目录<code>/filemanager</code>。</p>

<div class="admonition note">
<p class="admonition-title">注意</p>
<p>默认账号密码为 <code>admin</code></p>
</div>

<h3 id="语法">语法</h3>

<pre><code>filemanager [url] [scope] {
    database        path
    no_auth
    locale          [en|jp|...]
    allow_commands  [true|false]
    allow_edit      [true|false]
    allow_new       [true|false]
    allow_publish   [true|false]
    commands        cmd1 cmd2...
    css             path
}
</code></pre>

<ul>
<li><p><strong>url</strong> 是您将访问文件管理器的URL路径。默认为/。</p></li>

<li><p><strong>database</strong> 是存储设置的数据库的路径。</p></li>

<li><p><strong>no_auth</strong> 禁用身份验证</p></li>
</ul>

<p>以下选项只是默认值：它们将仅用作新用户的默认选项。创建用户后，其设置应通过 Web UI 进行更改。当使用 no_auth 选项时，以下将定义用户权限。</p>

<p>范围是您要浏览的目录的路径，相对或绝对，默认为./。
语言环境是新用户（可用语言）的默认语言。</p>

<ul>
<li><p><strong>allow_commands</strong> allow commands选项的默认值。</p></li>

<li><p><strong>allow_edit</strong> allow edit选项的默认值。</p></li>

<li><p><strong>allow_new</strong> allow new 选项的默认值。</p></li>

<li><p><strong>allow_publish</strong> allow publish选项的默认值。</p></li>
</ul>

<p>命令是默认的可用命令。</p>

<ul>
<li><strong>css</strong> 是具有自定义样式表的文件的路径</li>
</ul>

<p>如果您使用<code>http.hugo</code>，<code>http.jekyll</code> 或任何其他使用文件管理器作为基础的插件，初始语法略有不同。这个范围和 url 选项是颠倒的，你应该写插件的名字而不是 filemanager 。</p>

<h3 id="关于数据库">关于数据库</h3>

<p>默认情况下，数据库将被保存在 <code>.caddy</code> 目录，在一个名为 <code>filemanager</code> 的子目录中。每个文件名称都是主机和基本<code>URL</code>的组合的散列。</p>

<p>如果您不设置数据库路径，并且更改主机或基本 URL，那么您的设置将被重置。因此，强烈建议您设置此选项。当您不设置它时，您将收到一个警告，告诉您当前数据库应该使用的值。</p>

<p>当您设置相对路径时，它将始终与<code>.caddy/filemanager</code> 目录相关。尽管如果您希望将数据库存储在其他位置，您也可以使用绝对路径。</p>

<h2 id="http-filter">http.filter</h2>

<h2 id="http-forwardproxy">http.forwardproxy</h2>

<h2 id="http-git">http.git</h2>

<p>git 插件可以通过简单的 git push 来部署您的站点。</p>

<p>git 指令启动在服务器的生命周期中运行的服务例程。当服务启动时，它会克隆存储库。当服务器还在运行时，它会拉取最新的东西。你也可以设置一个 webhook 在 push 后立即拉取。以正常的 Git 方式，pull只包含更改，所以它非常有效。</p>

<p><a href="https://github.com/abiosoft/caddy-git/blob/master/README.md">完整文档-英文</a></p>

<h3 id="例子-3">例子</h3>

<p><strong>基本语法</strong></p>

<pre><code>git repo [path]
</code></pre>

<ul>
<li><strong>repo</strong> 是存储库的URL; 支持 SSH 和 HTTPS URL。</li>
<li><strong>path</strong> 是相对于站点根的路径，将存储库克隆到 默认是站点根。</li>
</ul>

<p>这种简化的语法从主机每3600秒（1小时）抽取，只适用于公开存储库。</p>

<p><strong>完整的语法</strong></p>

<pre><code>git [repo path] {
	repo        repo
	path        path
	branch      branch
	key         key
	interval    interval
	clone_args  args
	pull_args   args
	hook        path secret
	hook_type   type
	then        command [args...]
	then_long   command [args...]
}
</code></pre>

<ul>
<li><p><strong>repo</strong> 是存储库的URL; 支持SSH和HTTPS URL。</p></li>

<li><p><strong>path</strong> 是将存储库克隆到的路径; 默认是站点根。它可以是绝对的或相对的（到站点根）。</p></li>

<li><p><strong>branch</strong> 是分支或标签; 默认是主分支。<code>{latest}</code> 是最新标签的占位符，可确保最新的标签始终拉取。</p></li>

<li><p><strong>key</strong> 是SSH私钥的路径; 适用于私有存储库。</p></li>

<li><p><strong>interval</strong> 是拉取间隔的秒数; 默认为3600（1小时），最小为5.间隔-1时候禁用周期性拉取。</p></li>

<li><p><strong>clone_args</strong> 是额外的 cli 参数,传递给 <code>git clone</code> 例如：<code>--depth=1</code>。<code>git clone</code> 当第一次获取源时调用。</p></li>

<li><p><strong>pull_args</strong> 是额外的cli args 传递<code>给git pull</code> 例如：  <code>-s recursive -X theirs</code>。<code>git pull</code> 当源被更新时使用。</p></li>

<li><p><strong>path 和 secret</strong> 用于创建一个 webhook，当 push 后可拉取最新代码 。这仅限于支持的webhooks。目前，Github，Gitlab 和 Travis 挂钩仅支持秘密。</p></li>

<li><p><strong>type</strong> 是 webhook 类型的使用。webhook类型是默认自动检测的，但它可以被显式设置为一个受支持的 webhook。这是通用 webhook 的一个要求。</p></li>

<li><p><strong>command</strong> 是成功拉取后执行的命令;然后是<strong>args</strong>，任何参数都可以传递给命令。对于多个命令，您可以有多个这样的行。<strong>then_long</strong>是用于长时间执行的命令，应该在后台运行。</p></li>
</ul>

<p>块中的每个属性都是可选的。路径和repo可以在第一行中指定，就像在第一个语法中一样，或者可以在块中指定其他值。</p>

<p><strong>基本例子</strong></p>

<pre><code>git github.com/user/myproject subfolder
</code></pre>

<p>公共存储库拉入 站点根目录下的<code>subfolder</code></p>

<p><strong>更多的控制</strong></p>

<pre><code>git {
	repo     git@github.com:user/myproject
	branch   v1.0
	key      /home/user/.ssh/id_rsa
	path     subfolder
	interval 86400
}
</code></pre>

<p>私有库每天被拉入<code>subfolder</code>目录<code>v1.0</code>一次。</p>

<p><strong>拉取后执行命令</strong></p>

<pre><code>git github.com/user/site {
	path  ../
	then  hugo --destination=/home/user/hugosite/public
}
</code></pre>

<p>此示例在每次拉取后都会生成 <code>hugo</code> 的静态站点。</p>

<p><strong>指定一个webhook</strong></p>

<pre><code>git git@github.com:user/site {
	hook /webhook secret-password
}
</code></pre>

<p><code>/webhook</code> 是路径，<code>secret-password</code> 是 hook 密码（如果适用）。 Webhooks 支持 GitHub，Gitlab，BitBucket，Travis 和 Gogs。</p>

<p>如果您的密码包含特殊字符，您可能需要引号。</p>

<div class="admonition note">
<p class="admonition-title">译者注</p>
<p>如果需要支持 码云、coding <code>hook_type  generic</code></p>
</div>

<p><strong>通用webhook</strong></p>

<pre><code>{
	&quot;ref&quot; : &quot;refs/heads/branch&quot;
}
</code></pre>

<p>这是通用 webhook 的预期有效载荷。<code>branch</code> 是分支名称，如 <code>master</code>。</p>

<h2 id="http-gopkg">http.gopkg</h2>

<h2 id="http-grpc">http.grpc</h2>

<h2 id="http-hugo">http.hugo</h2>

<h2 id="http-ipfilter">http.ipfilter</h2>

<h2 id="http-jekyll">http.jekyll</h2>

<h2 id="http-jwt">http.jwt</h2>

<p>该中间件基于JSON Web令牌（JWT）实现了 Caddy 的授权层。您可以在[jwt.io]（<a href="https://jwt.io）上了解有关在应用程序中使用JWT的更多信息。">https://jwt.io）上了解有关在应用程序中使用JWT的更多信息。</a></p>

<h3 id="基本语法">基本语法</h3>

<pre><code>jwt [path]
</code></pre>

<p>默认情况下，路径下的所有资源将使用JWT验证进行安全保护。要指定需要保护的资源列表，请使用多个声明。请务必阅读插件文档，以正确配置服务器来验证您的 token 。</p>

<div class="admonition note">
<p class="admonition-title">重要</p>
<p>您必须在名为<code>JWT_SECRET</code>（HMAC）<em>或</em><code>JWT_PUBLIC_KEY</code>（RSA）的环境变量中设置用于构建您的令牌的秘密。否则，您的 token 将默认无法验证。球童将在没有这个值的情况下启动，但是必须在签名请求验证时出现。</p>
</div>

<h3 id="高级语法">高级语法</h3>

<p>您可以选择使用声明信息来进一步控制对路线的访问。在&rdquo;jwt&rdquo;块中，您可以根据声明的值指定允许或拒绝访问的规则。
如果声明是 json 数组的字符串，则 allow 和 deny 指令将检查数组是否包含指定的字符串值。如果数组中的任何值匹配，则允许或拒绝规则将生效。</p>

<pre><code>jwt {
   path [path]
   redirect [location]
   allow [claim] [value]
   deny [claim] [value]
}
</code></pre>

<p>要基于声明授权访问，请使用<code>allow</code>语法。要拒绝访问，请使用<code>deny</code>关键字。您可以使用多个关键字来实现复杂的访问规则。如果任何<code>allow</code>访问规则返回true，则允许访问。如果“deny”规则为真，访问将被拒绝。拒绝规则将允许该声明的任何其他值。</p>

<p>例如，假设你有一个带有&rdquo;user：someone&rdquo;和&rdquo;role：member&rdquo;的令牌。如果您有以下访问块：</p>

<pre><code>jwt {
   path [path]
   redirect [location]
   allow [claim] [value]
   deny [claim] [value]
}
</code></pre>

<p>中间件将以”role：member“的形式拒绝所有人，但将允许具有特定用户名为”someone“的用户。允许使用“role：admin”或 ”role：foo”的不同用户，因为拒绝规则将允许任何没有角色成员的用户。</p>

<p>如果设置了可选的“redirect”，则如果访问被拒绝，中间件将发送重定向到所提供的位置（HTTP 303）而不是访问被拒绝的代码。</p>

<h3 id="传递令牌进行验证的方式">传递令牌进行验证的方式</h3>

<p>有三种方式传递令牌进行验证：（1）在“授权”标题中，（2）作为cookie，（3）作为URL查询参数。中间件将按照列出的顺序查找那些位置，如果找不到任何令牌，则返回“401”。</p>

<table>
<thead>
<tr>
<th>Method</th>
<th>Format</th>
</tr>
</thead>

<tbody>
<tr>
<td>授权标题</td>
<td><code>Authorization: Bearer &lt;token&gt;</code></td>
</tr>

<tr>
<td>Cookie</td>
<td><code>&quot;jwt_token&quot;: &lt;token&gt;</code></td>
</tr>

<tr>
<td>URL 查询参数</td>
<td><code>/protected?token=&lt;token&gt;</code></td>
</tr>
</tbody>
</table>

<h3 id="构造一个有效的标记">构造一个有效的标记</h3>

<p>JWT由三部分组成：标题，声明和签名。为了正确构建JWT，建议您使用适合您语言的JWT库。至少，此授权中间件期望存在以下字段：</p>

<p><strong>header</strong></p>

<pre><code class="language-JSON">{
“typ”：“JWT”，
“alg”：“HS256 | HS384 | HS512 | RS256 | RS384 | RS512”
}
</code></pre>

<p><strong>声明</strong></p>

<p>如果要限制您的令牌的有效期到某个时间段，请使用 “exp” 字段声明令牌的到期时间。这个时间应该是整数格式的 Unix 时间戳。</p>

<pre><code class="language-JSON">{
“exp”：1460192076
}
</code></pre>

<h3 id="代理令牌中的声明">代理令牌中的声明</h3>

<p>您可以在索赔部分添加额外的索赔。一旦令牌被验证，您所包含的声明将作为标题传递给下游资源。由于token 已由 Caddy 验证，您可以放心，这些标题代表您的令牌的有效声明。例如，如果您在令牌中包含以下声明：</p>

<pre><code class="language-json">{
  &quot;user&quot;: &quot;test&quot;,
  &quot;role&quot;: &quot;admin&quot;,
  &quot;logins&quot;: 10,
  &quot;groups&quot;: [&quot;user&quot;, &quot;operator&quot;],
  &quot;data&quot;: {
    &quot;payload&quot;: &quot;something&quot;
  }
}
</code></pre>

<p>以下标头将被添加到代理到您的应用程序的请求中：</p>

<pre><code>Token-Claim-User: test
Token-Claim-Role: admin
Token-Claim-Logins: 10
Token-Claim-Groups: user,operator
Token-Claim-Data.payload: something
</code></pre>

<p>token声明将始终转换为字符串。如果您希望您的声明是另一种类型，请记住在使用声明之前将其转换回来。嵌套的JSON对象将被格式化。在上面的示例中，您可以看到嵌套的“payload”字段被转化为“data.payload”。</p>

<p>所有前缀为<code>Token-Claims -</code>的请求头都被从上游转发出去，所以用户不能欺骗他们。</p>

<p>HTTP 标头中不允许使用特殊字符的声明将被转义为 URL。例如， Auth0 要求将索引命名为完整的URL，例如</p>

<pre><code class="language-json">{
  &quot;http://example.com/user&quot;: &quot;test&quot;
}
</code></pre>

<p>URL转义会导致一些难以理解的 header</p>

<pre><code>Token-Claims-Http：％2F％2Fexample.com％2Fuser：test
</code></pre>

<p>如果您只关心路径的最后一部分，您可以使用<code>strip_header</code>指令在路径的最后一部分之前删除所有内容。</p>

<pre><code>jwt {
  path /
  strip_header
}
</code></pre>

<p>当结合上述权利要求时，它将导致 header</p>

<pre><code>Token-Claim-User: test
</code></pre>

<h3 id="允许公共访问某些路径">允许公共访问某些路径</h3>

<p>在某些情况下，您可能希望允许公开访问特定路径，而不使用有效的 token。例如，您可能希望保护所有路由，除了访问<code>/login</code>路径。你可以用<code>except</code>指令来做到这一点。</p>

<pre><code>jwt {
  path /
  except /login
}
</code></pre>

<p>以<code>/login</code>开头的每个路径将从JWT令牌要求中除外。所有其他路径将被保护。在您将路径设置为根目录的情况下，您还可能希望允许访问所谓的裸机或根域，同时保护其他所有内容。您可以使用允许访问裸域的“allowroot”指令。例如，如果您有以下配置块:</p>

<pre><code>jwt {
  path /
  except /login
  allowroot
}
</code></pre>

<p>对&rdquo;<a href="https://example.com/login&quot;">https://example.com/login&quot;</a> 和 &ldquo;<a href="https://example.com/&quot;">https://example.com/&quot;</a> 的请求都将被允许，而不需要有效的 token。任何其他路径将需要一个有效的 token。</p>

<h3 id="允许公共访问不需要令牌">允许公共访问不需要令牌</h3>

<p>在某些情况下，无论是否存在有效的令牌，都可以访问页面。一个例子可能是Github主页或公共存储库，即使是注销用户也应该可见。在这种情况下，您需要解析可能存在的任何有效的令牌，并将声明传递给应用程序，并将其留给应用程序以决定用户是否可以访问。您可以使用指令<code>passthrough</code>为此：</p>

<pre><code>jwt {
  path /
  passthrough
}
</code></pre>

<p>应该注意的是，“passthrough”将始终允许访问所提供的路径，而不管一个令牌是否存在或有效，以及不考虑<code>allow</code> /<code>deny</code>指令。应用程序将负责处理已解析的请求。</p>

<h3 id="指定用于验证令牌的密钥">指定用于验证令牌的密钥</h3>

<p>指定用于验证令牌的关键材料有两种方法。如果您在容器中运行Caddy或通过像 Systemd 这样的 init 系统运行，可以使用 HMAC 的环境变量<code>JWT_SECRET</code>或用于RSA（PEM编码的公钥）的<code>JWT_PUBLIC_KEY</code>来直接指定密钥。您不能同时使用这两者，因为它会在 JWT 规范中打开一个已知的安全漏洞。当您运行多个站点时，所有这些站点都必须使用相同的密钥来验证令牌。</p>

<p>当您从一个Caddyfile运行多个站点时，您可以指定包含PEM编码的公钥或HMAC密码的文件的位置。再次，您不能同时使用这两个网站，因为它会导致安全漏洞。但是，您可以在不同的站点上使用不同的方法，因为配置是独立的。</p>

<p>对于 RSA tokens:</p>

<pre><code>jwt {
  path /
  publickey /path/to/key.pem
} 
</code></pre>

<p>对于 HMAC:</p>

<pre><code>jwt {
  path /
  secret /path/to/secret.txt
}
</code></pre>

<p>当您将密钥材料存储在文件中时，此中间件将缓存结果，并使用文件上的修改时间来确定自上次请求以来密码是否已更改。这允许您在不担心文件锁定问题的情况下，通过编写新的密钥来旋转您的密钥或使令牌无效(尽管您仍然应该检查您的写是否成功，然后使用新密钥发出令 token)。</p>

<p>如果您有多个公共密匙或秘密，应该被认为是有效的，那么在不同的文件中使用多个声明来处理密钥或秘密。如果任何密钥验证了 token ，将允许授权。。</p>

<pre><code>jwt {
  path /
  publickey /path/to/key1.pem
  publickey /path/to/key2.pem
}
</code></pre>

<h3 id="可能的错误状态码">可能的错误状态码</h3>

<table>
<thead>
<tr>
<th>代码</th>
<th>原因</th>
</tr>
</thead>

<tbody>
<tr>
<td>401</td>
<td>未授权 - 无令牌，令牌失败验证，令牌已过期</td>
</tr>

<tr>
<td>403</td>
<td>禁止 - 令牌有效，但被拒绝，因为允许或DENY规则</td>
</tr>

<tr>
<td>303</td>
<td>返回401或403，并重新启动。这优先于401或403状态。</td>
</tr>
</tbody>
</table>

<p>###</p>

<div class="admonition warning">
<p class="admonition-title">警告</p>
<p>JWT验证只取决于验证正确的签名，并且令牌未到期。您还可以设置<code>nbf</code>字段，以防止在某个时间戳之前进行验证。规范中的其他字段，如 &ldquo;aud&rdquo;，&rdquo;iss，&rdquo;sub&rdquo;，&rdquo;iat&rdquo;和&rdquo;jti&rdquo; 不会影响验证步骤。</p>
</div>

<h2 id="http-login">http.login</h2>

<p>基于 github.com/tarent/loginsrv 的 Caddy 登录指令。根据后端检查登录名，然后返回为 JWT 令牌。该指令旨在与 http.jwt 中间件一起使用。</p>

<p>支持以下提供程序（登录后端）：</p>

<ul>
<li>Htpasswd</li>
<li>OSIAM</li>
<li>Simple (配置用户/密码对)</li>
<li>Github, Google OAuth2 登录</li>
</ul>

<h3 id="例子-4">例子</h3>

<p><strong>简单例子</strong></p>

<pre><code>jwt {
    path /
    allow sub bob
}

login / {
         simple bob=secret,alice=secret
}
</code></pre>

<p>根上下文 / 由 jwt 中间件保护。用户 alice 和 bob 可以登录</p>

<p><strong>htpasswd 文件 用户</strong></p>

<pre><code>header /private Cache-Control &quot;no-cache, no-store, must-revalidate&quot;
  
jwt {
  path /private
  redirect /login
  allow sub demo
}

login {
  success_url /private
  htpasswd file=passwords
}
</code></pre>

<p>保护路径 /private 。用户在 htpasswd 文件中 。</p>

<p><strong>Github 示例更多的定制</strong></p>

<pre><code>jwt {
  path /my-account
  redirect /login
}

login {
  github client_id={$github_client_id},client_secret={$github_client_secret}

  success_url /my-account
  logout_url /
  template login_template.html
  jwt_expiry 24h
  cookie_expiry 2400h
}
</code></pre>

<p>Githu b登录，从环境变量中获取 Github api 凭证。模板、重定向 url 和过期时间配置。</p>

<h2 id="http-mailout">http.mailout</h2>

<h2 id="http-minify">http.minify</h2>

<p>Caddy 插件，可实时实现CSS，HTML，JSON，SVG和XML的压缩。它使用[tdewolff的库]（<a href="https://github.com/tdewolff/minify）">https://github.com/tdewolff/minify）</a></p>

<h3 id="语法-1">语法</h3>

<pre><code>minify paths...  {
    if          a cond b
    if_op       [and|or]
    disable     [js|css|html|json|svg|xml]
    minifier    option value
}
</code></pre>

<ul>
<li><strong>paths</strong> 是空格分隔的文件路径来压缩。如果没有指定，整个网站将被细化。</li>
<li><strong>if</strong> 指定条件。默认情况下，多个if一起合并。<strong>a</strong> 和 <strong>b</strong> 是任何字符串，可以使用[请求占位符]（/http-server/#placeholders）。<strong>cond</strong>是条件，可能的值在[rewrite]（/http/#rewrite）中解释（也有一个<code>if</code>语句）。</li>
<li><strong>if_op</strong> 指定如何评估ifs; 默认值为<code>and</code>。</li>
<li><strong>disable</strong> 用于指示要禁用哪些minifiers; 默认情况下，它们都被激活。</li>
<li><strong>minifier</strong> 设置<strong>value</strong> ** <strong>option</strong>在该分组。当选项为 true 或 false 时，其省略被称为&rdquo;true&rdquo;。可能的选项如下。</li>
</ul>

<h3 id="minifiers选项">Minifiers选项</h3>

<table>
<thead>
<tr>
<th>文件后缀</th>
<th>选项</th>
<th>价值</th>
<th>说明</th>
</tr>
</thead>

<tbody>
<tr>
<td>css，svg</td>
<td>decimals</td>
<td>number</td>
<td>保留默认属性值。</td>
</tr>

<tr>
<td>xml，html</td>
<td>keep_whitespace</td>
<td>true </td>
<td>false</td>
</tr>

<tr>
<td>html</td>
<td>keep_end_tags</td>
<td>true </td>
<td>false</td>
</tr>

<tr>
<td>html</td>
<td>keep_document_tags</td>
<td>true </td>
<td>false</td>
</tr>

<tr>
<td>html</td>
<td>keep_default_attr_vals</td>
<td>true </td>
<td>false</td>
</tr>

<tr>
<td>html</td>
<td>keep_conditional_comments</td>
<td>true </td>
<td>false</td>
</tr>
</tbody>
</table>

<p>有关每个选项以及每个分选程序如何工作的更多信息，请阅读[tdewolff / minify的文档]（<a href="https://github.com/tdewolff/minify/blob/master/README.md）。">https://github.com/tdewolff/minify/blob/master/README.md）。</a></p>

<p>#＃ 例子</p>

<p>压缩网站的所有受支持文件：</p>

<pre><code>Minify all of the supported files of the website:
</code></pre>

<p>只压缩<code>/ assets</code>文件夹的内容：</p>

<pre><code>minify /assets
</code></pre>

<p>只有minify css文件：</p>

<pre><code>minify {
    disable html svg json xml js
}
</code></pre>

<p>缩小除<code>/api</code>之外的整个网站：</p>

<pre><code>minify  {
    if {path} not_match ^(\/api).*
}
</code></pre>

<p>压缩<code>/ assets'文件夹的文件，除了</code>/ assets / js`：</p>

<pre><code>minify /assets {
    if {path} not_match ^(\/assets\/js).*
}
</code></pre>

<h2 id="http-nobots">http.nobots</h2>

<h2 id="http-prometheus">http.prometheus</h2>

<h2 id="http-proxyprotocol">http.proxyprotocol</h2>

<h2 id="http-ratelimit">http.ratelimit</h2>

<p>ratelimit 用于根据客户端的 IP 地址限制请求处理速率。过多的请求将被终止，返回 429 错误（太多请求），并且 X-RateLimit-RetryAfter头 将被返回。</p>

<h3 id="例子-5">例子</h3>

<p><strong>对于单一资源：</strong></p>

<pre><code>ratelimit path rate burst unit
</code></pre>

<p>路径是要应用速率限制的文件或目录; 速率是每个时间单位的有限请求（r / s，r / m，r / h）（例如1）; 突发是客户端可以超过的最大突发大小; burst&gt; = rate（例如2）; 单位是时间间隔（目前支持：秒，分，小时）。</p>

<p><strong>对于多种资源：</strong></p>

<pre><code>ratelimit rate burst unit {
    whitelist CIDR
    resources
}
</code></pre>

<p>白名单是将您的信任ips列入白名单的关键字，CIDR是您不想执行限制的IP范围; 资源是要应用速率限制的文件/目录列表，每行一个。</p>

<div class="admonition note">
<p class="admonition-title">注意</p>
<p>如果您不想对某些特殊资源应用速度限制，请在路径前添加^。</p>
</div>

<p><strong>将客户端限制为每秒2个请求（3个突发）到 /r 中的任何资源：</strong></p>

<pre><code>ratelimit /r 2 3 second
</code></pre>

<p><strong>对于列出的路径，如果请求来自1.2.3.4或192.168.1.0/30（192.168.1.0〜192.168.1.3），请勿执行速率限制，将客户端限制为每分钟2个请求（突发2），并始终忽略 /DIR/app.js：</strong></p>

<pre><code>ratelimit 2 2 minute {
    whitelist 1.2.3.4/32
    whitelist 192.168.1.0/30
    /foo.html
    /dir
    ^/dir/app.js
}
</code></pre>

<h2 id="http-realip">http.realip</h2>

<p><code>X-Forwarded-For</code> 如果您在 CDN 或 Proxy 后面运行，此插件允许您从标头查看实际的客户端IP 。它会使得日志和其他下游指令将看到实际的客户端IP，而不是代理。</p>

<p>实施安全措施，使X-Forwarded-For不会被盗用未经授权的IP范围。</p>

<p>真正的IP模块在您在代理服务器后面运行 Caddy 的情况下很有用。</p>

<p>在这些情况下，实际的客户端IP将被存储在HTTP头中，通常是“X-Forwarded-For”。</p>

<p>这产生的问题是依赖客户端IP地址的其他指令，如<code>ipfilter</code>或<code>git</code>在这些情况下不会总是正常工作。</p>

<p>这个中间件将无缝安全地从相应的头读取真实的IP地址并将请求中的代理 IP 替换为真实 IP。在 Caddy 的日志、文件和其他插件中使用了新的 IP 。</p>

<h3 id="例子-6">例子</h3>

<pre><code class="language-Caddyfile">realip [cidr] {
    header name
    from   cidr [cidr... ]
    strict
}
</code></pre>

<ul>
<li><p><strong>name</strong> 是包含实际IP地址的头的名称。默认为 X-Forwarded-For。</p></li>

<li><p><strong>cidr</strong> 是预期代理服务器的地址范围。作为安全措施，IP头只能从已知的代理服务器接受。必须是一个有效的 cidr 块符号。这可以多次指定。</p></li>

<li><p><strong>strict</strong> 如果指定，将拒绝来自具有403状态的未知代理IP的请求。如果没有指定，它将简单地将原始IP保留在适当位置。</p></li>
</ul>

<h3 id="cidr-块">CIDR 块</h3>

<p>CIDR是指定IP范围的标准符号。要允许单个IP，请在ip后使用/32指定无掩码：123.222.31.4/32。要允许所有IP（并接受任何人的X-Forwarded-For标头），请使用0.0.0.0/0。大多数云服务应该以这种格式在某个地方发布其ip范围。</p>

<p><strong>示例</strong></p>

<pre><code class="language-Caddyfile">realip {
    从1.2.3.4/32
    从2.3.4.5/32
}
</code></pre>

<h3 id="预设">预设</h3>

<p>如果您想将Caddy用于云端服务，则提供一些助手。只需在您的 Caddyfile 中指定下面的 Caddy 片段即可使用内置的 IP 列表激活它。</p>

<table>
<thead>
<tr>
<th>提供者</th>
<th>别名</th>
<th>Caddyfile Snippet</th>
</tr>
</thead>

<tbody>
<tr>
<td>Cloudflare</td>
<td><code>cloudflare</code></td>
<td><code>realip cloudflare</code></td>
</tr>

<tr>
<td>Google Cloud Platform</td>
<td><code>gcp</code></td>
<td><code>realip gcp</code></td>
</tr>

<tr>
<td>Rackspace Cloud</td>
<td><code>rackspace</code></td>
<td><code>realip rackspace</code></td>
</tr>
</tbody>
</table>

<p>对其他云提供商的拉动请求将受到额外的预设。</p>

<p>#＃# 其他例子</p>

<p>只能从几个已知的IP中读取“X-Forwarded-For”的简单用法：</p>

<pre><code class="language-Caddyfile">realip {
    from 1.2.3.4/32
    from 2.3.4.5/32
}
</code></pre>

<p>预设和IP的简单使用：</p>

<pre><code class="language-Caddyfile">realip cloudflare 1.2.3.4/32
</code></pre>

<p>或者</p>

<pre><code class="language-Caddyfile">realip cloudflare {
    从1.2.3.4/32
}
</code></pre>

<p>或者</p>

<pre><code class="language-Caddyfile">realip {
    from cloudflare
    from 1.2.3.4/32
}
</code></pre>

<h2 id="http-reauth">http.reauth</h2>

<h2 id="http-restic">http.restic</h2>

<h2 id="http-upload">http.upload</h2>

<p>使用 API ​​和 HTTP 的 POST 或 PUT 方法上传文件。</p>

<p>使用像 curl 这样的工具，可以方便地使用诸如 构建工具、downloads-to-be 之类的文件</p>

<h3 id="简单例子">简单例子</h3>

<p><strong>快速简单上传</strong></p>

<pre><code>curl \
  -T /etc/os-release \
  https://127.0.0.1/wp-upload/os-release
</code></pre>

<p>上传<code>os-release</code>到路径<code>wp-upload</code>。</p>

<p><strong>快速删除</strong></p>

<pre><code>curl -X DELETE \
  https://127.0.0.1/wp-upload/os-release
</code></pre>

<p>删除，<code>wp-upload/os-release</code>如果它存在。</p>

<p><strong>移动或重命名文件</strong></p>

<pre><code>curl -X MOVE \
  -H &quot;destination: /wp-upload/old-release&quot; \
  https://127.0.0.1/wp-upload/os-release
</code></pre>

<p>该文件将以新名称提供。</p>

<h3 id="警告">警告</h3>

<p>使用TLS进行上传，否则您的数据和授权令牌可能被第三方截取。</p>

<p>此插件会显示文件系统实现向上传者抛出的一些错误，例如目标设备上的空间不足。</p>

<p>Golang 当前解码 MIME Multipart（与POST请求一起使用）的方式会导致您上传的任何文件在上传期间保存在内存中。</p>

<h3 id="语法-2">语法</h3>

<pre><code>upload &lt;path&gt; {
    to                    &quot;&lt;directory&gt;&quot;
    yes_without_tls

    filenames_form        &lt;none|NFC|NFD&gt;
    filenames_in          &lt;u0000-uff00&gt; [&lt;u0000-uff00&gt;| …]
    random_suffix_len     0..N
    promise_download_from &lt;path&gt;

    max_filesize          0..N
    max_transaction_size  0..N

    hmac_keys_in          &lt;keyid_0=base64(binary)&gt; [&lt;keyid_1=base64(binary)&gt;| …]
    timestamp_tolerance   &lt;0..32&gt;
    silent_auth_errors
}

</code></pre>

<p>这些设置是必需的：</p>

<ul>
<li><p><strong>path</strong> 路径是插件对任何上传的反应的路由，它将被剥离，并没有任何结果文件和目录的一部分。</p></li>

<li><p><strong>to</strong> 是现有的目标目录。必须是引用的绝对路径。当使用Linux时，建议将其放在支持<strong>O_TMPFILE</strong>的文件系统上 ，例如（但不限于）<code>ext4</code>或<code>XFS</code>。</p></li>
</ul>

<p>这些是可选的：</p>

<ul>
<li><p><strong>yes_without_tls</strong> 插件在没有TLS 的范围内使用，则必须设置 <code>yes_without_tls</code> 。
当您得到指示文件系统的错误时，将其设置为其中一个值不能正确地转换名称。(如果有疑问，可以去NFC;使用NFD的Mac pc。默认是不强制执行任何东西。</p></li>

<li><p><strong>filenames_in</strong> 允许您将文件名限制为指定的 Unicode 范围。范围的范围必须以十六进制表示，并以字母<code>u</code>开始  。
使用此设置可以防止用户在希望拉丁和/或中文字母的情况下上传文件，例如西里尔文。</p></li>

<li><p><strong>random_suffix_len</strong> 如果&gt; 0，将导致所有文件名获得随机的后缀。
后缀将以<code>_</code>（下划线）字母开始，并放在任何扩展名之前。
例如，<code>image.png</code> 将按照 <code>image_a107xm.png</code> 配置值 <code>6</code> 进行写入。利用 <code>promise_download_from</code> 来获取生成的文件名。关闭时
默认为<code>0</code> 。</p></li>

<li><p><strong>promise_download_from</strong> 是一个表示URI引用的字符串，例如路径。
通过响应 <code>Location</code> 所有接收到的文件的 HTTP 头（多次，如果需要），将用于指示上传的文件可以在哪里下载。
您最有可能要将其设置为上传path。
默认值为“”，表示不会 <code>Location</code> 发送 HTTP 头。</p></li>

<li><p>通过<strong>max_filesize</strong> 可以限制单个文件的大小。除非设置<code>0</code>，这意味着“无限制”，是默认值，它是以字节为单位。</p></li>

<li><p><strong>max_transaction_size</strong> 是类似的，但适用于在一个请求中上传一个或多个文件。例如，当使用<code>MIME</code>多部件上传时。
当前未定义 <code>max_filesize</code> &gt; <code>max_transaction_size</code> 的行为;
将 <code>max_transaction_size</code> 设置为多个 <code>max_filesize</code> 。</p></li>
</ul>

<p>一些传输编码，如base64，知道注释。那些，或者超长标题，
可以使用比例如<code>max_transaction_size</code>的更多字节来传输更多的字节。
通过使用不同的插件(http)来缓解这个问题。限制输入字节数
不知道任何编码。设置一个上限约为<code>1.4×2.05×max_transaction_size</code>。
这个插件为更好的性能编写文件块。限制以几千字节的整数来计算
构成一个完整的块。</p>

<p>可选，但如果您想使用内置的授权功能，则需要:</p>

<ul>
<li><p><strong>hmac_keys_in</strong> 是一个空格分隔的 <code>username → shared secret</code> 关联列表。
后者是二进制数据，使用 base64 编码，推荐长度为32个八位字节。</p></li>

<li><p><strong>timestamp_tolerance</strong> 通过授权设置请求的有效性，并用于考虑上传者和服务器计算机之间的时钟漂移差异。
它的功率为2，其默认值为2（如：±4秒= 1 &lt;&lt; 2 = 2 ** 2）。通过可靠的同步时钟将其设置为1或0。</p></li>

<li><p><strong>silent_auth_errors</strong> 如果设置插件的内置授权将不会返回自己的 HTTP 错误。
相反，请求将被交给下一个中间件，然后这个中间件很可能返回一个 HTTP 错误。这是一种模糊网站接受上传的便捷方式。</p></li>
</ul>

<h3 id="教程">教程</h3>

<p>添加到您的 Caddyfile：</p>

<pre><code>upload /web/path {
    to &quot;/var/tmp&quot;
}
</code></pre>

<p>&hellip;并上传一个文件：</p>

<pre><code># HTTP PUT
curl \
  -T /etc/os-release \
  https://127.0.0.1/web/path/from-release
</code></pre>

<p>&hellip;或更多文件（根据需要创建子目录）：</p>

<pre><code># HTTP POST
curl \
  -F gitconfig=@.gitconfig \
  -F id_ed25519.pub=@.ssh/id_ed25519.pub \
  https://127.0.0.1/web/path/
</code></pre>

<p>&hellip;你可以这样移动和删除：</p>

<pre><code># MOVE is 'mv'
curl -X MOVE \
  -H &quot;Destination: /web/path/to-release&quot; \
  https://127.0.0.1/web/path/from-release

# DELETE is 'rm -r'
curl -X DELETE \
  https://127.0.0.1/web/path/to-release
</code></pre>

<h3 id="授权-签名">授权：签名</h3>

<p>该插件支持请求授权方案签名，尽管不支持其领域或任何其他算法，而不是hmac-sha256。
这是一个具有预共享密钥和随机数||时间戳的HMAC方案。</p>

<p>发送头授权和其他两个，格式如下，每次上传请求：</p>

<pre><code>Authorization: Signature keyId=&quot;(username)&quot;,algorithm=&quot;hmac-sha256&quot;,headers=&quot;timestamp token&quot;,signature=&quot;(see below)&quot;
Timestamp: (current UNIX time)
Token: (a nonce)
</code></pre>

<p>您可以使用 BASH 和 OpenSSL 生成新密钥（密码，预共享密钥），并将其编码为base64：</p>

<pre><code>SECRET=&quot;$(openssl rand -base64 32)&quot;

# printf &quot;%s\n&quot; &quot;${SECRET}&quot;
# TWF0dCBIb2x0IGRvZXNuJ3QgdXBkYXRlIGhpcyBNYWM=

</code></pre>

<p>一个完整的脚本用于上传某些内容将是：</p>

<pre><code>#!/bin/bash
# hmac_keys_in mark=Z2VoZWlt
#
UPLOADER=&quot;mark&quot;
SECRET=&quot;geheim&quot;

TIMESTAMP=&quot;$(date --utc +%s)&quot;
# length and contents are not important, &quot;abcdef&quot; would work as well
NONCE=&quot;$(cat /dev/urandom | tr -d -c '[:alnum:]' | head -c $(( 32 - ${#TIMESTAMP} )))&quot;

SIGNATURE=&quot;$(printf &quot;${TIMESTAMP}${NONCE}&quot; \
             | openssl dgst -sha256 -hmac &quot;${SECRET}&quot; -binary \
             | openssl enc -base64)&quot;

# order does not matter; any skipped fields in Authorization will be set to defaults
exec curl -T \
  --header &quot;Timestamp: ${TIMESTAMP}&quot; \
  --header &quot;Token: ${NONCE}&quot; \
  --header &quot;Authorization: Signature keyId='${UPLOADER}',signature='${SIGNATURE}'&quot; \
  &quot;&lt;filename&gt;&quot; &quot;&lt;url&gt;&quot;
</code></pre>

<h3 id="配置示例">配置示例</h3>

<p>中欧和西欧某人使用的主机将被配置为接受拉丁语的文件名，一些希腊符文和几个数学符号：</p>

<pre><code>upload /college/curriculum {
    to &quot;/home/ellen_baker/inbox&quot;
    filenames_form NFC
    filenames_in u0000–u007F u0100–u017F u0391–u03C9 u2018–u203D u2152–u217F
}
</code></pre>

<p>Linux发行版的主机可能会更加严格：</p>

<pre><code>upload /binhost/gentoo {
    to &quot;/var/portage/packages&quot;
    filenames_in u0000–u007F
    timestamp_tolerance 0
}
tls {
    …
    clientcas /etc/ssl/dist-uploaders-CA.crt
}
</code></pre>

<p>&hellip;而在东亚人将与三个朋友共享空间，这样的:</p>

<pre><code>upload /wp-uploads {
    to &quot;/var/www/senpai/wp-uploads&quot;
    max_filesize 16777216
    filenames_in u0000–u007F u0100–u017F u0391–u03C9 u2018–u203D u3000–u303f u3040–u309f u30a0–u30ff u4e00–9faf uff00–uffef

    timestamp_tolerance 3
    silent_auth_errors

    hmac_keys_in yui=eXVp hina=aGluYQ== olivia=b2xpdmlh james=amFtZXM=
}

</code></pre>

<h2 id="http-webdav">http.webdav</h2>


			<aside class="copyright" role="note">
				
				&copy; 2018 Released under the MIT license &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

<nav class="pagination" aria-label="Footer">
  <div class="previous">
  
      <a href="https://docs.getcaddy.cn/readme/" title="Caddy 中文文档">
        <span class="direction">
          Previous
        </span>
        <div class="page">
          <div class="button button-previous" role="button" aria-label="Previous">
            <i class="icon icon-back"></i>
          </div>
          <div class="stretch">
            <div class="title">
              Caddy 中文文档
            </div>
          </div>
        </div>
      </a>
  
  </div>

  <div class="next">
  
      <a href="https://docs.getcaddy.cn/dns/" title="">
        <span class="direction">
          Next
        </span>
        <div class="page">
          <div class="stretch">
            <div class="title">
              
            </div>
          </div>
          <div class="button button-next" role="button" aria-label="Next">
            <i class="icon icon-forward"></i>
          </div>
        </div>
      </a>
  
  </div>
</nav>





			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

    <script>
    
      var base_url = 'https:\/\/docs.getcaddy.cn\/';
      var repo_id  = 'mholt\/caddy';
    
    </script>

    <script src="https://docs.getcaddy.cn/javascripts/application.js"></script>
    

    <script>
      /* Add headers to scrollspy */
      var headers   = document.getElementsByTagName("h2");
      var scrollspy = document.getElementById('scrollspy');

      if(scrollspy) {
        if(headers.length > 0) {
          for(var i = 0; i < headers.length; i++) {
            var li = document.createElement("li");
            li.setAttribute("class", "anchor");

            var a  = document.createElement("a");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", headers[i].innerHTML);
            a.innerHTML = headers[i].innerHTML;

            li.appendChild(a)
            scrollspy.appendChild(li);
          }
        } else {
          scrollspy.parentElement.removeChild(scrollspy)
        }


        /* Add permanent link next to the headers */
        var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

        for(var i = 0; i < headers.length; i++) {
            var a = document.createElement("a");
            a.setAttribute("class", "headerlink");
            a.setAttribute("href", "#" + headers[i].id);
            a.setAttribute("title", "Permanent link")
            a.innerHTML = "#";
            headers[i].appendChild(a);
        }
      }
    </script>

    

    <script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

